---
layout: post
title: "Chocopy Hacking Part 4: Compiling to WASM"
description: "Building a WASM compiler backend for a subset of Python 3"
date: 2022-10-11
category: "Compilers"
---

In the fourth part of my Chocopy Compiler Hacking series, I will be discussing how I built the backend to compile [Chocopy](https://chocopy.org/) (a statically typed subset of Python 3) to WebAssembly. 

For those unfamiliar with the topic, Chocopy is a subset of Python 3 with static type annotations. WebAssembly is a binary instruction format designed for high performance web applications. WebAssembly can run in most browsers and other JavaScript environments such as NodeJS.

In this post, I'll discuss the overall approach and highlight some interesting details of the WebAssembly backend concerning memory management and runtime.

For reference, the source code for the compiler is available on Github, and past projects in this series are documented on this blog:
- [Source Code](https://github.com/yangdanny97/chocopy-python-compiler)
- [Part 1: Frontend/typechecker](https://yangdanny97.github.io/blog/2020/05/29/chocopy-typechecker)
- [Part 2: JVM backend](https://yangdanny97.github.io/blog/2021/08/26/chocopy-jvm-backend)
- [Part 3: CIL backend](https://yangdanny97.github.io/blog/2022/05/22/chocopy-cil-backend)

# Overview

As with previous projects in this series, I defined a set of goals beforehand to give myself the best possible shot at completing the project.

This time, I had three main goals. The first was a learning goal: I wanted to learn more about WASM as a compilation target and learn how it integrates with JavaScript applications. Although it was tempting to rely on imported JavaScript to do the heavy lifting, I really wanted to avoid this - so my second goal was to keep the runtime minimal. Since I knew very little about WASM going into the project, I was worried about how much work it would take - to reduce the risk of failure, my final goal was to reuse existing compiler passes as much as possible and avoid overthinking the memory management aspect.

Following the same pattern as the JVM and CIL backends, I decided to emit a plaintext format (WAT) from the compiler and use a tool (wat2wasm) to convert them into WASM binaries that could be loaded by a JavaScript runtime. Like CIL (and unlike JVM), both the plaintext format and assembler were officially supported parts of the WASM toolchain. I set up the test suite to actually run the compiled WASM programs, allowing me to be confident that this backend matched the behavior of the other backends.

# Learning Resources and References

I found that the [WebAssembly docs on MDN](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format) were really helpful both as high-level overview of WASM/WAT as well as a technical reference for implementing the JavaScript integration/runtime.

I also referenced the [online notes from UC San Diego's CSE231](https://ucsd-cse231-w21.github.io/), a course that implements a Chocopy-to-WASM compiler/REPL. The notes on memory layouts and classes were a useful sanity check to make sure I was on the right track, and I reused their simple memory allocation strategy for this project. 

When I implemented the frontend of this compiler a few years ago, someone told me about the existence of PPCI. Prior to starting this project, I revisited it and found that it also had a [WASM backend implemented in Python](https://ppci.readthedocs.io/en/latest/reference/wasm.html#wasm). However, in the end this was not a particularly useful reference for the project since the subset of Python that PPCI's WASM backend supported was much smaller than Chocopy's feature set.

# Implementation

Compared to CIL and JVM, WASM is at a lower level of abstraction - it has manual memory management and no built-in concept of classes. This meant that I had to decide memory layouts for each data type, and implement various memory operations and dynamic dispatch from scratch. The other features in Chocopy - expressions, function calls, control flow, etc - were pretty straightforward to implement, so I won't discuss them in this blog post.

## Data Types

Integers are represented as i64, while booleans and pointers for reference types (strings, lists, objects, nonlocals) are represented as i32. The null pointer (`None`) is represented by the address 0, and checking if an object is null is the same as checking if its address is 0. 

## Memory Management

Memory is allocated using a simple linear allocator that tracks the position of the next unallocated address using a global variable. Allocated memory is ever reclaimed or freed and there is no garbage collection. 

Each program generated by the compiler includes a set of memory-related utilities, implemented in around 300 lines of hand-written WASM:
- allocation
- copying
- null-checking
- bounds-checking
- string concatenation
- list concatenation
- string indexing
- string equality

### Strings and Lists

Strings are represented in utf-8 format, and store their length as an i32 followed by 1 byte for each character. Lists also store their length as an i32, followed by 8 bytes for each element. The length of strings and lists are always stored in the first four bytes, allowing similar implementations for equality checks, iteration, indexing, and concatenation. 

For memory safety, indexing operations have bounds checks. List operations also have a null check, since `None` is a legal initial value for a list-typed variable. These checks are implemented as simple control flow leading to `unreachable` instructions.

### Classes

The vtables for every class are stored at the beginning of the memory buffer, and the allocator is initialized past this value so that the vtable memory is never overwritten by later allocations.

The memory layout for classes and objects is as follows:
- first four bytes are the offset of the object's vtable
- 8 bytes for each attribute

The ordering of attributes and methods in the vtable is consistent between parent classes and their children.

## Runtime Support and Imported Functions

The JavaScript runtime for the generated WASM code is extremely minimal. It defines the memory buffer and four functions that are imported by the WASM code:
1. print integers
2. print booleans
3. print strings
4. assertions 

The following NodeJS script is all the runtime needed for the generated WASM:

```javascript
const wasm_path = process.argv[2];

function logString(offset) {
    // first 4 bytes is the length
    const length = new Uint32Array(memory.buffer, offset, 1)[0];
    // next [length] bytes is the string contents, encoded as utf-8
    const bytes = new Uint8Array(memory.buffer, offset + 4, length);
    const string = new TextDecoder('utf8').decode(bytes);
    console.log(string);
}

function logInt(val) {
    // cast BigInt to a number for pretty-printing w/o the "n"
    // this may truncate or break for values that take >53 bits
    console.log(Number(val));
}

function logBool(val) {
    // this is a 32 bit number, either 1 or 0
    console.log(val !== 0);
}

function assert(val, line) {
    if (!val) {
        throw new Error("Assertion failed on line " + line.toString());
    }
}

const memory = new WebAssembly.Memory({
    initial: 10,
    maximum: 100
});

const importObject = {
    imports: {
        logString: x => logString(x),
        logInt: x => logInt(x),
        logBool: x => logBool(x),
        assert: (x, y) => assert(x, y)
    },
    js: {
        mem: memory
    },
};

const fs = require('fs');

const wasmBuffer = fs.readFileSync(wasm_path);
WebAssembly.instantiate(wasmBuffer, importObject);
```

# Final Thoughts

Overall, I'm pretty satisfied with this project. I succeeded in compiling Chocopy programs into WebAssembly with a minimal runtime, and I learned a lot about WASM and how it integrates with JavaScript applications.

I was initially hesitant to start to this project since I wasn't sure how much work it would take. In the end, adding WASM support to this compiler was less work than expected - around 800 lines of Python, 300 lines of hand-written WASM, and 50 lines of JavaScript for the runtime. In total, it took me around 2-3 weekends to complete.

The process of building and extending this compiler over the last 2-3 years has been pretty enjoyable, but get the sense that I'm approaching the limits of this compiler as a learning tool. Aside from possibly making an LLVM backend in the future, I think I'm ready to start something new. Perhaps something that allows me to experiment with different parsing techniques, since parsing was something I explicitly omitted from this project and it's becoming somewhat relevant to my job.

